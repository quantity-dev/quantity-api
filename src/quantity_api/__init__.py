"""Quantity API."""

from typing import Any, Final, Protocol, Self, runtime_checkable

import optype as op

type Unit = Any  # TODO: unit-api

__version__: Final = "0.0.1.dev0"
__all__ = ["__version__", "Quantity"]

@runtime_checkable
class Quantity[V, U: Unit](Protocol):
    @property
    def value(self) -> V: ...
    @property
    def unit(self) -> U: ...

    ### Dunder Methods
    def __eq__[B](self, other: Self[op.CanEq[V, B], U], /) -> B: ...
    def __ne__[B](self, other: Self[op.CanEq[V, B], U], /) -> B: ...
    def __lt__[B](self, other: Self[op.CanOrd[V, B], U], /) -> B: ...
    def __le__[B](self, other: Self[op.CanOrd[V, B], U], /) -> B: ...
    def __gt__[B](self, other: Self[op.CanOrd[V, B], U], /) -> B: ...
    def __ge__[B](self, other: Self[op.CanOrd[V, B], U], /) -> B: ...
    
    def __pos__(self) -> Self[op.CanPos[V], U]: ...
    def __neg__(self) -> Self[op.CanNeg[V], U]: ...
    def __abs__(self) -> Self[op.CanAbs[V], U]: ...

    def __add__[B](self, other: Self[op.CanAdd[V, B], U], /) -> Self[op.CanAdd[V, B], U]: ...
    def __radd__[B](self, other: Self[op.CanAdd[V, B], U], /) -> Self[op.CanAdd[V, B], U]: ...
    def __sub__[B](self, other: Self[op.CanSub[V, B], U], /) -> Self[op.CanSub[V, B], U]: ...
    def __rsub__[B](self, other: Self[op.CanSub[V, B], U], /) -> Self[op.CanSub[V, B], U]: ...

    def __mul__[B](self, other: Self[op.CanMul[V, B], U], /) -> Self[op.CanMul[V, B], U]: ...
    def __rmul__[B](self, other: Self[op.CanMul[V, B], U], /) -> Self[op.CanMul[V, B], U]: ...
    def __truediv__[B](self, other: Self[op.CanDiv[V, B], U], /) -> Self[op.CanDiv[V, B], U]: ...
    def __rtruediv__[B](self, other: Self[op.CanDiv[V, B], U], /) -> Self[op.CanDiv[V, B], U]: ...

    def __pow__(self, other: int | Self[op.CanPow[V], U], /) -> Self[op.CanPow[V], U]: ...
    def __rpow__(self, other: int | Self[op.CanPow[V], U], /) -> Self[op.CanPow[V], U]: ...
